// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model User {
  id       String   @id @default(auto()) @map("_id") @db.ObjectId
  name     String
  email    String   @unique
  password String
  tweets   Tweets[]
}

model Tweets {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  tweet       String
  createdAt   DateTime @default(now())
  updatedDate DateTime @updatedAt
  User        User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String?  @db.ObjectId
}

//-------------------------------------------------------//
// ======== Dive into Prisma Fundamental ================//
//--------------------------------------------------------//

// Introspection vs Migration
// In Prisma, there are two concepts for creating models: introspection and migration.

// Introspection is used when we don't have a local model in our code, but the schema has been created in the cloud. By running `prisma db pull`, a new model is automatically generated based on the cloud schema. If we have a database in advance then we need to use Introspection.

// On the other hand, migration is the process of manually creating a new model. After creating a model manually, we use the `npx prisma db push` command to update the database model.

model TestUser {
  id    Int    @id @map("_id")
  email String @unique
  name  String
  role  Role?  @default(USER)
  // @@map("TestUser"): Specifies that the model should be mapped to a database table named "TestUser."
  // @@unique([name, role]): Defines a unique constraint, ensuring that each combination of name and role must be unique in the database.

  @@unique([name, role])
  @@map("TestUser")
}

enum Role {
  USER
  ADMIN
}

// @id @unique this are called attribute

// here Int for fields representing IDs, counts, or any other numerical values that should be integers we can also use String in id if the id is string

// here @map("_id") directive is applied to the _id field of the User model. This means that in the actual database, the column corresponding to the _id field will be named "_id" instead of the default name generated by Prisma.

// ----- Prisma Relationship ----------- //

// One to one relationship 
// Each user has one profile (1-1)

model TestUser2 {
  id        Int           @id @map("_id")
  email     String        @unique
  name      String
  role      Role2?        @default(USER)
  profileId Int?          @unique
  profile   TestProfile2? @relation(fields: [profileId], references: [id])

  @@unique([name, role])
  @@map("TestUser2")
}

model TestProfile2 {
  id  Int    @id @map("_id")
  bio String

  // userId Int @unique
  user TestUser2?
}

enum Role2 {
  USER
  ADMIN
}

model TestUser3 {
  id        String @id @map("_id")
  firstName String
  lastName  String

  profile Testprofile3?

  @@unique([firstName, lastName])
}

model Testprofile3 {
  id            String @id @map("_id")
  userFirstName String
  userLastName  String

  user TestUser3 @relation(fields: [userFirstName, userLastName], references: [firstName, lastName])

  @@unique([userFirstName, userLastName])
}

// One to many relationship 
// Each user can have multiple post (1-n)

model TestUser4 {
  id        Int           @id @map("_id")
  email     String        @unique
  name      String
  profileId Int?          @unique
  profile   TestProfile4? @relation(fields: [profileId], references: [id])

  //each user can have multiple posts
  posts Post[]
}

model TestProfile4 {
  id  Int    @id @map("_id")
  bio String

  // userId Int @unique
  user TestUser4?
}

model Post {
  id        Int       @id @map("_id")
  authorId  Int       @unique
  title     String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  published Boolean   @default(false)
  user      TestUser4 @relation(fields: [authorId], references: [id])
}

// Many to many relationship 
// Each user can have catagoryToPost like A,B category and each category can have another id name (1-n)

model TestUser5 {
  id        Int           @id @map("_id")
  email     String        @unique
  name      String
  profileId Int?          @unique
  profile   TestProfile5? @relation(fields: [profileId], references: [id])

  //each user can have multiple posts
  posts Post5[]
}

model TestProfile5 {
  id  Int    @id @map("_id")
  bio String

  // userId Int @unique
  user TestUser5?
}

model Post5 {
  id        Int       @id @map("_id")
  authorId  Int       @unique
  title     String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  published Boolean   @default(false)
  user      TestUser5 @relation(fields: [authorId], references: [id])

  categories Category[] @relation(fields: [categoryId], references: [id])
  categoryId Int[]
}

model Category {
  id     Int     @id @map("_id")
  name   String
  postId Int[]
  posts  Post5[] @relation(fields: [postId], references: [id])
}
